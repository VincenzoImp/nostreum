{
  "language": "Solidity",
  "sources": {
    "contracts/NostrLinkr.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title NostrLinkr\n * @dev Smart contract to link Ethereum addresses with Nostr public keys\n * @notice This contract allows users to create verifiable links between their Ethereum address and Nostr identity\n */\ncontract NostrLinkr {\n\n    // Mapping from Ethereum address to Nostr public key\n    mapping(address => bytes32) public addressPubkey;\n    \n    // Mapping from Nostr public key to Ethereum address\n    mapping(bytes32 => address) public pubkeyAddress;\n\n    // Event emitted when a new link is created\n    event LinkrPushed(address indexed addr, bytes32 indexed pubkey);\n    \n    // Event emitted when a link is removed\n    event LinkrPulled(address indexed addr, bytes32 indexed pubkey);\n\n    /**\n     * @dev Main function to link Ethereum address to Nostr pubkey\n     * @param id The Nostr event ID (hash of the event)\n     * @param pubkey The Nostr public key to link with\n     * @param createdAt Unix timestamp when the event was created\n     * @param kind The Nostr event kind (must be 27235 for linkage)\n     * @param tags JSON string of event tags (must be empty array \"[]\")\n     * @param content The content of the event (must be sender's address without 0x prefix)\n     * @param sig The Schnorr signature of the Nostr event (64 bytes)\n     */\n    function pushLinkr(\n        bytes32 id, \n        bytes32 pubkey, \n        uint256 createdAt, \n        uint256 kind,\n        string memory tags,\n        string memory content,\n        bytes calldata sig\n    ) external {\n        // Validate signature length (Schnorr signatures are 64 bytes)\n        require(sig.length == 64, \"Invalid signature length\");\n        \n        // Validate event kind - 27235 is the designated kind for Nostr linkage\n        require(kind == 27235, \"Invalid kind for Nostr Linkr\");\n        \n        // Validate timestamp - allow some future tolerance (10000 seconds)\n        require(createdAt <= block.timestamp+10000, \"CreatedAt must be in the past\");\n        \n        // Validate tags - must be empty for linkage events\n        require(keccak256(bytes(tags)) == keccak256(bytes(\"[]\")), \"Tags must be empty for Nostr Linkr\");\n        \n        // Validate content - must match sender's address without 0x prefix\n        require(\n            keccak256(bytes(content)) == keccak256(bytes(addressToStringNoPrefix(msg.sender))), \n            \"Content must be sender's address without 0x prefix\"\n        );\n        \n        // Verify the Nostr event signature using NIP-01 and BIP-340 standards\n        require(verifyNostrEvent(id, pubkey, createdAt, kind, tags, content, sig), \"Invalid Nostr signature\");\n        \n        // Remove any existing linkage for this address to prevent conflicts\n        bytes32 existingPubkey = addressPubkey[msg.sender];\n        if (existingPubkey != bytes32(0)) {\n            delete pubkeyAddress[existingPubkey];\n        }\n        \n        // Remove any existing linkage for this pubkey to prevent conflicts\n        address existingAddress = pubkeyAddress[pubkey];\n        if (existingAddress != address(0)) {\n            delete addressPubkey[existingAddress];\n        }\n        \n        // Create new bidirectional linkage\n        addressPubkey[msg.sender] = pubkey;\n        pubkeyAddress[pubkey] = msg.sender;\n        \n        // Emit event for the new linkage\n        emit LinkrPushed(msg.sender, pubkey);\n    }\n\n    /**\n     * @dev Remove the linkage between caller's address and their Nostr pubkey\n     */\n    function pullLinkr() external {\n        // Get the linked pubkey for the caller\n        bytes32 pubkey = addressPubkey[msg.sender];\n        require(pubkey != bytes32(0), \"No link found for this address\");\n        \n        // Remove bidirectional linkage\n        delete addressPubkey[msg.sender];\n        delete pubkeyAddress[pubkey];\n        \n        // Emit event for the removed linkage\n        emit LinkrPulled(msg.sender, pubkey);\n    }\n\n    /**\n     * @dev Verify Nostr event according to NIP-01 specification\n     * @param eventId The expected event ID (hash)\n     * @param pubkey The public key that signed the event\n     * @param createdAt Unix timestamp of event creation\n     * @param kind The event kind\n     * @param tags JSON string of event tags\n     * @param content The event content\n     * @param signature The Schnorr signature (64 bytes)\n     * @return bool True if the event is valid, false otherwise\n     */\n    function verifyNostrEvent(\n        bytes32 eventId,\n        bytes32 pubkey,\n        uint256 createdAt,\n        uint256 kind,\n        string memory tags,\n        string memory content,\n        bytes calldata signature\n    ) public pure returns (bool) {\n        // Validate signature length\n        require(signature.length == 64, \"Signature must be 64 bytes\");\n        \n        // Reconstruct the event hash according to Nostr specification\n        // Event serialization format: [0, pubkey, created_at, kind, tags, content]\n        string memory serializedEvent = string(abi.encodePacked(\n            '[0,\"',\n            bytesToHexNoPrefix(abi.encodePacked(pubkey)),\n            '\",',\n            uint2str(createdAt),\n            ',',\n            uint2str(kind),\n            ',',\n            tags,\n            ',\"',\n            content,\n            '\"]'\n        ));\n        \n        // Compute SHA-256 hash of the serialized event\n        bytes32 computedHash = sha256(bytes(serializedEvent));\n        \n        // Verify the computed hash matches the provided event ID\n        require(computedHash == eventId, \"Event ID mismatch\");\n        \n        // Verify Schnorr signature according to BIP-340\n        return verifySchnorrSignature(pubkey, eventId, signature);\n    }\n\n    /**\n     * @dev Simplified Schnorr verification for Nostr (BIP-340)\n     * @param pubkey The public key (32 bytes)\n     * @param message The message that was signed (32 bytes)\n     * @param signature The signature to verify (64 bytes)\n     * @return bool True if signature is valid (simplified validation)\n     * @notice This is a simplified implementation for demonstration purposes\n     */\n    function verifySchnorrSignature(\n        bytes32 pubkey,\n        bytes32 message,\n        bytes calldata signature\n    ) internal pure returns (bool) {\n        // Extract r and s components from signature\n        bytes32 r = bytes32(signature[0:32]);  // First 32 bytes\n        bytes32 s = bytes32(signature[32:64]); // Last 32 bytes\n        \n        // For on-chain verification, we'll use a simplified approach\n        // In a production environment, you might want to use a more robust implementation\n        // or an oracle for Schnorr verification\n        \n        // Convert to integers for range checking\n        uint256 sInt = uint256(s);\n        uint256 rInt = uint256(r);\n        \n        // Secp256k1 curve order (n)\n        uint256 curveOrder = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n        \n        // Check if s is in valid range (0 < s < n)\n        if (sInt == 0 || sInt >= curveOrder) {\n            return false;\n        }\n        \n        // Check if r is in valid range (0 < r < n)\n        if (rInt == 0 || rInt >= curveOrder) {\n            return false;\n        }\n        \n        // For now, we'll trust that the signature was verified client-side\n        // In production, implement full BIP-340 verification or use an oracle\n        return true;\n    }\n\n    /**\n     * @dev Convert bytes to hexadecimal string with 0x prefix\n     * @param data The bytes to convert\n     * @return string The hexadecimal representation\n     */\n    function bytesToHex(bytes memory data) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    /**\n     * @dev Convert unsigned integer to string\n     * @param _i The integer to convert\n     * @return string The string representation\n     */\n    function uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        \n        // Calculate string length\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        \n        // Build string from right to left\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /**\n     * @dev Convert address to hexadecimal string with 0x prefix\n     * @param _addr The address to convert\n     * @return string The hexadecimal representation with 0x prefix\n     */\n    function addressToString(address _addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    /**\n     * @dev Utility function for testing - compute event hash\n     * @param pubkey The public key\n     * @param createdAt Unix timestamp\n     * @param kind Event kind\n     * @param tags Event tags\n     * @param content Address content\n     * @return bytes32 The computed event hash\n     */\n    function getEventHash(\n        bytes32 pubkey,\n        uint256 createdAt,\n        uint256 kind,\n        string memory tags,\n        address content\n    ) external pure returns (bytes32) {\n        // Serialize event according to Nostr specification\n        string memory serializedEvent = string(abi.encodePacked(\n            '[0,\"',\n            bytesToHex(abi.encodePacked(pubkey)),\n            '\",',\n            uint2str(createdAt),\n            ',',\n            uint2str(kind),\n            ',',\n            tags,\n            ',\"',\n            addressToString(content),\n            '\"]'\n        ));\n        \n        // Return SHA-256 hash of serialized event\n        return sha256(bytes(serializedEvent));\n    }\n\n    /**\n     * @dev Convert bytes to hexadecimal string without 0x prefix\n     * @param data The bytes to convert\n     * @return string The hexadecimal representation without prefix\n     */\n    function bytesToHexNoPrefix(bytes memory data) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(data.length * 2);\n        for (uint256 i = 0; i < data.length; i++) {\n            str[i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[1 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    /**\n     * @dev Convert address to hexadecimal string without 0x prefix\n     * @param _addr The address to convert\n     * @return string The hexadecimal representation without 0x prefix (40 characters)\n     */\n    function addressToStringNoPrefix(address _addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(40); // No 0x prefix, just 40 chars\n        for (uint256 i = 0; i < 20; i++) {\n            str[i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\n            str[1 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\n        }\n        return string(str);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}